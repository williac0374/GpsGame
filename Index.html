<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Random Target Locator</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <style>
        /* Make sure the map and fullscreen button fill the screen */
        body, html {
            margin: 0;
            padding: 0;
            height: 100%;
            overflow: hidden;
        }
        #map {
            height: 100%;
            width: 100%;
        }
        /* Fullscreen button styles */
        #fullscreen-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 10px 15px;
            background-color: rgba(255, 255, 255, 0.8);
            border: 1px solid #ccc;
            cursor: pointer;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <!-- Fullscreen Button -->
    <div id="fullscreen-btn">Fullscreen</div>
    <div id="map"></div>

    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <script>
        const map = L.map('map').setView([51.505, -0.09], 13);  // Default map view

        // Add OpenStreetMap layer
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
        }).addTo(map);

        targetMarker = null;
        let userMarker = null;  // For the user's current location
        let previousPosition = null;
        const initialTargetRadius = 5; // Initial value for target radius in meters
        let targetRadius = initialTargetRadius; // Current target radius
        const halfMile = 804.672; // Meters
        const radiusIncrementFactor = 0.1; // Adjust to control how quickly radius grows

        // Function to generate random latitude and longitude within half a mile
        function getRandomLocation(lat, lon, radius) {
            const r = radius / 111300; // Convert radius from meters to degrees
            const u = Math.random();
            const v = Math.random();
            const w = r * Math.sqrt(u);
            const t = 2 * Math.PI * v;
            const newLat = w * Math.cos(t) + lat;
            const newLon = w * Math.sin(t) / Math.cos(lat) + lon;
            return [newLat, newLon];
        }

        // Function to set a new random target
        function setRandomTarget(lat, lon) {
            if (targetMarker) map.removeLayer(targetMarker);
            const [targetLat, targetLon] = getRandomLocation(lat, lon, halfMile);
            targetMarker = L.circle([targetLat, targetLon], { radius: targetRadius, color: 'red' }).addTo(map);
            return [targetLat, targetLon];
        }

        // Watch the user's location and update the marker
        let targetPosition = null;
        navigator.geolocation.watchPosition(position => {
            const userLat = position.coords.latitude;
            const userLon = position.coords.longitude;
            map.setView([userLat, userLon], 15);

            // If userMarker exists, move it. Otherwise, create it.
            if (userMarker) {
                userMarker.setLatLng([userLat, userLon]);
            } else {
                userMarker = L.circle([userLat, userLon], { radius: 10 + targetRadius, color: 'blue' }).addTo(map);
            }

            // Calculate distance from the previous position and increase target radius accordingly
            if (previousPosition) {
                const distanceMoved = map.distance([userLat, userLon], previousPosition);
                targetRadius += distanceMoved * radiusIncrementFactor;
            }
            previousPosition = [userLat, userLon];

            // If no target, generate a new one
            if (!targetPosition) {
                targetPosition = setRandomTarget(userLat, userLon);
            } else {
                const distance = map.distance([userLat, userLon], targetPosition);
                if (distance <= targetRadius) {
                    alert("Target reached! Generating new target.");
                    
                    // Reset targetRadius to initial value
                    targetRadius = initialTargetRadius;

                    // Set a new target
                    targetPosition = setRandomTarget(userLat, userLon);
                }
            }
        }, error => {
            console.error("Error getting location:", error);
        }, options => {
              enableHighAccuracy: true,
  			  timeout: 5000, // Maximum time to wait for a position (in milliseconds)
              maximumAge: 0 // Don't use cached position data
        });

        // Fullscreen functionality
        const fullscreenButton = document.getElementById('fullscreen-btn');

        fullscreenButton.addEventListener('click', () => {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
                fullscreenButton.textContent = 'Exit Fullscreen';
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                    fullscreenButton.textContent = 'Fullscreen';
                }
            }
        });

        // Handle fullscreen change events to toggle button text
        document.addEventListener('fullscreenchange', () => {
            if (!document.fullscreenElement) {
                fullscreenButton.textContent = 'Fullscreen';
            }
        });
    </script>
</body>
</html>
